---
- title: Welcome to SCRIPT-8's lesson modes.
  shortTitle: Introduction
  slides:
  - text:
    - We are going to learn how to make games!
    - Each lesson will introduce a new concept.
  - text:
    - We will learn to draw characters and make them move.
    - We will learn to make worlds for our characters.
    - Then we'll add enemies and a bit of music, of course.
  - text:
    - You'll find the list of lessons in HELP.
    - Click HELP in the top menu.
    requirements:
      screen: HELP
  - screen: HELP
    text:
    - All the lessons are listed here, at the top.
    - Alright. That's enough introduction for now.
    - Let's start!
- title: Hello world!
  slides:
  - text:
    - In this lesson we will make a cassette that says "Hello world!".
    - This might not be too exciting, but all good stories start at the beginning.
    - So let's begin.
  - text:
    - We need to go to the CODE screen to write our code.
    - Click CODE in the top menu, and make sure to remove any existing code.
    requirements:
      screen: CODE
      game: ''
  - screen: CODE
    text:
    - 'Enter the following lines:'
    - XXdraw = () => {
    - XX  print(0, 0, 'Hello world!', 0)
    - XX}
  - game: |-
      draw = () => {
        print(0, 0, 'Hello world!', 0)
      }
    screen: CODE
    text:
    - Your first SCRIPT-8 cassette!
    - You should see 'Hello world!' drawn on the right.
    - If not it's because you're on a small screen.
  - screen: CODE
    text:
    - But that's OK. You can see the cassette full-screen in RUN.
    - Click RUN now. It might show up as RU if you're on a small screen.
    requirements:
      screen: RUN
  - text:
    - This is also what your friends will see when they load your cassette.
    - Speaking of which, save it! This is, after all, the beginning of your story.
    - Mouse over CASSETTE, on the menu, and click RECORD.
  - text:
    - You'll notice the URL changed.
    - It's your cassette's URL now.
    - You can share it with family and friends.
  - text:
    - In the next lesson we'll try to understand what we typed here.
    - It is always good to know what is going on.
    - Good-bye for now. See you soon!
- title: Hello many worlds!
  slides:
  - text:
    - In the previous lesson we learned how to draw letters.
    - Let's try to understand the code a bit. Then we can do more.
  - text:
    - Let's go over to the CODE screen.
    - Click CODE in the top menu.
    - Make sure to remove any existing code.
    requirements:
      screen: CODE
      game: ''
  - screen: CODE
    text:
    - Alright. Do you remember the 'Hello world!' code?
    - Enter it now. It's our starting point.
    - Don't remember it? That's OK. I'll do it for you. Click NEXT.
  - screen: CODE
    game: |-
      draw = () => {
        print(0, 0, 'Hello world!', 0)
      }
    text:
    - There are two functions here, 'draw' and 'print'.
    - SCRIPT-8 calls the 'draw' function 60 times per second.
    - It's a very important function.
    - It's part of what some call the game loop.
  - screen: CODE
    game: |-
      draw = () => {
        print(0, 0, 'Hello world!', 0)
      }
    text:
    - The other function, 'print', prints text on the screen.
    - 'It takes four parameters: x, y, text, and color.'
    - The first two, x and y, can be any integers from 0 to 127.
  - screen: CODE
    game: |-
      draw = () => {
        print(0, 0, 'Hello world!', 0)
      }
    text:
    - SCRIPT-8's resolution is 128px by 128px.
    - If you draw something at x = 128, well, that's past the right edge.
    - So you won't see it.
  - screen: CODE
    game: |-
      draw = () => {
        print(0, 0, 'Hello world!', 0)
      }
    text:
    - In fact, let's try that now. Change the numbers to something else.
    - And if you're on a small screen, remember to click RUN to see your work.
  - text:
    - WHAT HAPPENED?!
    - That is probably not what you expected.
    - It looks like the text smeared all over itself. Not good.
    - Go back to CODE so we can fix this.
    requirements:
      screen: CODE
  - screen: CODE
    text:
    - Remember how SCRIPT-8 calls 'draw' 60 times a second?
    - That explains this glitch. SCRIPT-8 drew your text multiple times.
    - But it didn't clear the screen between each draw.
  - screen: CODE
    text:
    - SCRIPT-8 drew your texts on top of each other. Like you told it to.
    - Well. Let's tell it to clear the screen before every draw!
  - screen: CODE
    text:
    - 'Add ''clear()'' at the beginning of your function. Like this:'
    - XXdraw = () => {
    - XX  clear()
    - XX  print(8, 8, 'Hello world!', 0)
    - XX}
  - screen: CODE
    text:
    - And now you can change the x or y, and the text will be drawn fresh every time.
    - Great.
    - 'We still haven''t talked about the last parameter: color.'
  - text:
    - It can be any integer from 0 to 7.
    - That's because there are 8 colors in SCRIPT-8.
    - Change the color. Experiment. Oh. What happens if you enter... a 9?
  - text:
    - It still drew something. Looks like... a 9 is like the color 1.
    - And 17 is also the color 1. Try it.
  - text:
    - So, the color numbers seem to wrap around, in groups of 8.
    - SCRIPT-8 does this by design. It can be useful in certain situations.
    - This is also known as modular arithmetic.
  - text:
    - This lesson is getting a bit long!
    - And the title said "Hello many worlds!" but we haven't taken care of that.
    - Can you guess how to fill the screen with 'Hello world!'? I'll do it for you.
  - game: |-
      draw = () => {
        clear()
        print(0, 0, 'Hello world!', 0)
        print(8, 8, 'Hello world!', 1)
        print(16, 16, 'Hello world!', 2)
        print(24, 24, 'Hello world!', 3)
        print(32, 32, 'Hello world!', 4)
        print(40, 40, 'Hello world!', 5)
        print(48, 48, 'Hello world!', 6)
        print(56, 56, 'Hello world!', 5)
        print(64, 64, 'Hello world!', 4)
        print(72, 72, 'Hello world!', 2)
        print(80, 80, 'Hello world!', 1)
        print(88, 88, 'Hello world!', 0)
        print(96, 102, 'Hello world!', 1)
        print(106, 116, 'Hello world!', 2)
      }
    screen: CODE
    text:
    - The last ones are a bit odd. Looks like they wrapped down.
    - That's because SCRIPT-8 will try to fit your text onto the screen.
    - This is a handy feature.
  - text:
    - OK. We have reached the end. I hope you learned something new.
    - The next lesson will be about SCRIPT-8's magical number slider.
    - Are you curious? I would be. See you in the next one!
- title: The magical number slider
  slides:
  - text:
    - This lesson has a promising name, don't you think?
    - But first we must take care of something important.
    - Let's go over to CODE, if you're not there already.
  - screen: CODE
    text:
    - Do you remember the last slide from our previous lesson? With all the 'Hello World!'s?
    - See if you can add that code here.
    - Don't worry if you forgot. I'll do it for you.
  - screen: CODE
    game: |-
      draw = () => {
        clear()
        print(0, 0, 'Hello world!', 0)
        print(8, 8, 'Hello world!', 1)
        print(16, 16, 'Hello world!', 2)
        print(24, 24, 'Hello world!', 3)
        print(32, 32, 'Hello world!', 4)
        print(40, 40, 'Hello world!', 5)
        print(48, 48, 'Hello world!', 6)
        print(56, 56, 'Hello world!', 5)
        print(64, 64, 'Hello world!', 4)
        print(72, 72, 'Hello world!', 2)
        print(80, 80, 'Hello world!', 1)
        print(88, 88, 'Hello world!', 0)
        print(96, 102, 'Hello world!', 1)
        print(106, 116, 'Hello world!', 2)
      }
    text:
    - Pay close attention to all the `print` lines.
    - Isn't there a lot lot of repetition?
    - We can do better.
  - text:
    - Can you improve this using loops?
    - (Remember SCRIPT-8 cassettes are written in JavaScript).
    - I'll show you one way.
  - screen: CODE
    text:
    - This code uses a for loop to print 10 lines.
    - Not bad. We got rid of the duplication.
    - But there's a better way.
    game: |-
      draw = () => {
        clear()
        let i
        for (i = 0; i < 10; i++) {
          print(8 * i, 8 * i, 'Hello world!', i % 7)
        }
      }
  - text:
    - SCRIPT-8 has a number of functions to help us do common tasks, such as looping over things.
    - 'One of them is `range`:'
    - XXrange([start=0], end, [step=1])
    game: |-
      draw = () => {
        clear()
        let i
        for (i = 0; i < 10; i++) {
          print(8 * i, 8 * i, 'Hello world!', i % 7)
        }
      }
  - screen: CODE
    text:
    - Here it is in action, next to the previous `for` code.
    - Much cleaner. No need to keep track of counter variables.
    - Now, about that magical slider.
    game: |-
      draw = () => {
        clear()
      //   let i
      //   for (i = 0; i < 10; i++) {
      //     print(8 * i, 8 * i, 'Hello world!', i % 7)
      //   }
        const lines = 10
        range(lines).forEach(i => {
          print(8 * i, 8 * i, 'Hello world!', i % 7)
        })
      }
  - screen: CODE
    text:
    - Actually, just a moment (sorry!).
    - See how the 'Hello World!'s don't go all the way to the bottom?
    - Let's fix that. Play around with the `range` argument until the text goes all the way down.
    game: |-
      draw = () => {
        clear()
      //   let i
      //   for (i = 0; i < 10; i++) {
      //     print(8 * i, 8 * i, 'Hello world!', i % 7)
      //   }
        const lines = 10
        range(lines).forEach(i => {
          print(8 * i, 8 * i, 'Hello world!', i % 7)
        })
      }
  - screen: CODE
    text:
    - You probably chose 15, right?
    - And how exactly did you do that?
    - You probably deleted 10, then typed 11. Deleted 11, typed 12.
    - Deleted 12, typed 13. Deleted 13, typed 14. Deleted 14, typed 15.
  - text:
    - That's also a lot of dupliplication.
    - All that typing just to find the right integer.
    - If only there was an easier way to do this.
  - screen: CODE
    text:
    - Do something for me. Click on the number 10 above.
    - And then, on your keyboard, hold the Shift key (or Command, if you're on a Mac.)
    - You see that slider? With the square in the middle?
    - Drag that square to the right. And watch the cassette on the right.
    game: |-
      draw = () => {
        clear()
        const lines = 10
        range(lines).forEach(i => {
          print(8 * i, 8 * i, 'Hello world!', i % 7)
        })
      }
  - text:
    - THE MAGICAL NUMBER SLIDER.
    - This lesson has come to an end.
    - Don't you wish your text editor had magical sliders?
- title: Spinning squares
  slides:
  - text:
    - In this lesson we will learn how to draw 'Hello World!' KIDDING.
    - How about something more exciting. How about squares? Spinning squares?
    - Let's get started.
  - text:
    - Before we begin, go to the CODE screen and delete anything there.
  - text:
    - SCRIPT-8 has various drawing functions. They're all listed in HELP.
    - "One of them is `rectStroke`:"
    - XXrectStroke(x, y, width, height, [color=0])
    screen: CODE
    game: ''
  - text:
    - Can you use `rectStroke` to draw eight concentric squares?
    - Try for a bit. If you're stuck, I'll do it for you. Click NEXT.
  - text:
    - Oops, sorry! That doesn't look quite right.
    - There's eight squares, but they all start on the same xy spot.
    - Can you fix it? I'll also try.
    screen: CODE
    game: |-
      draw = () => {
        clear()
        range(8).forEach(i => {
          const width = 8 * i
          const height = 8 * i
          const x = 64
          const y = 64
          rectStroke(x, y, width, height)
        })
      }
  - text:
    - Good. Every new square needs to start a bit further up and to the left.
    - Before we move on, there's a bit of duplication here. You see it?
    - Let's fix that.
    screen: CODE
    game: |-
      draw = () => {
        clear()
        range(8).forEach(i => {
          const width = 8 * i
          const height = 8 * i
          const x = 64 - width / 2
          const y = 64 - height / 2
          rectStroke(x, y, width, height)
        })
      }
  - text:
    - Better. One final thing. The colors are all the same.
    - Can you change that?
    screen: CODE
    game: |-
      draw = () => {
        clear()
        range(8).forEach(i => {
          const side = 8 * i
          const xy = 64 - side / 2
          rectStroke(xy, xy, side, side)
        })
      }
  - text:
    - If we would have set color to `i`, the last square would be invisible.
    - Hence the use of the modulus operator.
    screen: CODE
    game: |-
      draw = () => {
        clear()
        range(8).forEach(i => {
          const side = 8 * i
          const xy = 64 - side / 2
          const color = i % 7
          rectStroke(xy, xy, side, side, color)
        })
      }
  - text:
    - Now, this lesson is titled spinning squares. And we can't rotate a square using `rectStroke`.
    - "We'll use `polyStroke` for that:"
    - XXpolyStroke(points, [rotate, [x, y]], color)
  - text:
    - "`polyStroke` draws a closed polygon as defined by an array of points."
    - Let me show you. I'll draw one square using `polyStroke`.
    screen: CODE
    game: |-
      draw = () => {
        clear()
        range(8).forEach(i => {
          const side = 8 * i
          const xy = 64 - side / 2
          const color = i % 7
          rectStroke(xy, xy, side, side, color)
        })
      }
  - text:
    - Note you don't need to go back to the start. `polyStroke` closes the polygon.
    screen: CODE
    game: |-
      draw = () => {
        clear()
        const topLeft = [36, 36]
        const topRight = [91, 36]
        const bottomRight = [91, 91]
        const bottomLeft = [36, 91]
        polyStroke([topLeft, topRight, bottomRight, bottomLeft], 0)
      }
  - text:
    - We can rotate a polygon using `polyStroke`.
    - Set the rotation angle (in degrees) after points.
    - "For example, I'll rotate this rectangle by 5 degrees:"
    screen: CODE
    game: |-
      draw = () => {
        clear()
        const topLeft = [36, 36]
        const topRight = [91, 36]
        const bottomRight = [91, 91]
        const bottomLeft = [36, 91]
        polyStroke([topLeft, topRight, bottomRight, bottomLeft], 0)
      }
  - text:
    - You can also specify a rotation point. We won't go into that, but consult HELP for more information.
    - Back to our squares. Can you draw eight squares using `polyStroke`?
    screen: CODE
    game: |-
      draw = () => {
        clear()
        const topLeft = [36, 36]
        const topRight = [91, 36]
        const bottomRight = [91, 91]
        const bottomLeft = [36, 91]
        const angle = 5
        polyStroke([topLeft, topRight, bottomRight, bottomLeft], angle, 0)
      }
  - text:
    - Looking good. But how do we make the squares spin?
    - "This is where `update` comes in, another `game loop` function. SCRIPT-8 calls it before `draw`:"
    - XXupdate(state, input, elapsed)
    screen: CODE
    game: |-
      draw = () => {
        clear()
        range(8).forEach(i => {
          const halfSide = 8 * i / 2
          const topLeft = [64 - halfSide, 64 - halfSide]
          const topRight = [64 + halfSide, 64 - halfSide]
          const bottomRight = [64 + halfSide, 64 + halfSide]
          const bottomLeft = [64 - halfSide, 64 + halfSide]
          const angle = 5
          const color = i % 7
          polyStroke([topLeft, topRight, bottomRight, bottomLeft], angle, color)
        })
      }
  - text:
    - "`elapsed` is how many milliseconds passed since the last `update` call."
    - Ignore `input` for now. We'll talk about it in a future lesson.
    - Now, see that `state` parameter?
    - XXupdate(state, input, elapsed)
    screen: CODE
    game: |-
      update = (state, input, elapsed) => {
      }

      draw = () => {
        clear()
        range(8).forEach(i => {
          const halfSide = 8 * i / 2
          const topLeft = [64 - halfSide, 64 - halfSide]
          const topRight = [64 + halfSide, 64 - halfSide]
          const bottomRight = [64 + halfSide, 64 + halfSide]
          const bottomLeft = [64 - halfSide, 64 + halfSide]
          const angle = 5
          const color = i % 7
          polyStroke([topLeft, topRight, bottomRight, bottomLeft], angle, color)
        })
      }
  - text:
    - SCRIPT-8 is a state-based engine. You define the game's initial state at the beginning.
    - Then, during every `update`, modify the state as needed.
    - And draw your game in `draw`, which receives one parameter, `state`.
  - text:
    - That's the game loop! Nothing to it.
    - Alright. About that initial state. What do we want to hold in state?
    - How about our squares' rotation angle?
    screen: CODE
    game: |-
      update = (state, input, elapsed) => {
      }

      draw = () => {
        clear()
        range(8).forEach(i => {
          const halfSide = 8 * i / 2
          const topLeft = [64 - halfSide, 64 - halfSide]
          const topRight = [64 + halfSide, 64 - halfSide]
          const bottomRight = [64 + halfSide, 64 + halfSide]
          const bottomLeft = [64 - halfSide, 64 + halfSide]
          const angle = 5
          const color = i % 7
          polyStroke([topLeft, topRight, bottomRight, bottomLeft], angle, color)
        })
      }
  - text:
    - Notice how we're not declaring `angle` inside `draw`.
    - Instead, we'll get it from `state`.
    screen: CODE
    game: |-
      initialState = {
        angle: 5 // the rotation angle
      }

      update = (state, input, elapsed) => {
      }

      draw = (state) => {
        clear()
        const { angle } = state
        range(8).forEach(i => {
          const halfSide = 8 * i / 2
          const topLeft = [64 - halfSide, 64 - halfSide]
          const topRight = [64 + halfSide, 64 - halfSide]
          const bottomRight = [64 + halfSide, 64 + halfSide]
          const bottomLeft = [64 - halfSide, 64 + halfSide]
          const color = i % 7
          polyStroke([topLeft, topRight, bottomRight, bottomLeft], angle, color)
        })
      }
  - text:
    - Ready for the final part?
    - We need to make them spin. Can you guess how to do that?
    - "Hint: change the angle in `update`."
    screen: CODE
    game: |-
      initialState = {
        angle: 5 // the rotation angle
      }

      update = (state, input, elapsed) => {
      }

      draw = (state) => {
        clear()
        const { angle } = state
        range(8).forEach(i => {
          const halfSide = 8 * i / 2
          const topLeft = [64 - halfSide, 64 - halfSide]
          const topRight = [64 + halfSide, 64 - halfSide]
          const bottomRight = [64 + halfSide, 64 + halfSide]
          const bottomLeft = [64 - halfSide, 64 + halfSide]
          const color = i % 7
          polyStroke([topLeft, topRight, bottomRight, bottomLeft], angle, color)
        })
      }
  - text:
    - Ta-dah!
    - Isn't SCRIPT-8 fun?
    - See you in the next lesson.
    screen: CODE
    game: |-
      initialState = {
        angle: 5 // the rotation angle
      }

      update = (state, input, elapsed) => {
        state.angle = state.angle + elapsed / 10
      }

      draw = (state) => {
        clear()
        const { angle } = state
        range(8).forEach(i => {
          const halfSide = 8 * i / 2
          const topLeft = [64 - halfSide, 64 - halfSide]
          const topRight = [64 + halfSide, 64 - halfSide]
          const bottomRight = [64 + halfSide, 64 + halfSide]
          const bottomLeft = [64 - halfSide, 64 + halfSide]
          const color = i % 7
          polyStroke([topLeft, topRight, bottomRight, bottomLeft], angle, color)
        })
      }
- title: Swirly squares
  slides:
  - text:
    - If you were here for the previous lesson, you'll remember we drew eight concentric squares.
    - And then we made them spin, for much excitement.
  - text:
    - Let's make them swirl instead. We'll also add a title to our cassette.
    - And we'll put it on the SHELF!
    - Let's get started. Go to CODE. I'll load the squares for us.
  - text:
    - We need to give each square its own rotation angle.
    - For example, you could add 10 degrees per square, based on its position in the array.
    - "Like so:"
    screen: CODE
    game: |-
      initialState = {
        angle: 5 // the rotation angle
      }

      update = (state, input, elapsed) => {
        state.angle = state.angle + elapsed / 10
      }

      draw = (state) => {
        clear()
        const { angle } = state
        range(8).forEach(i => {
          const halfSide = 8 * i / 2
          const topLeft = [64 - halfSide, 64 - halfSide]
          const topRight = [64 + halfSide, 64 - halfSide]
          const bottomRight = [64 + halfSide, 64 + halfSide]
          const bottomLeft = [64 - halfSide, 64 + halfSide]
          const color = i % 7
          polyStroke([topLeft, topRight, bottomRight, bottomLeft], angle, color)
        })
      }
  - text:
    - This looks good. But each square needs to have the rotation angle based on its position AND time.
    - Let's create a function that does this.
    screen: CODE
    game: |-
      initialState = {
        angle: 5 // the rotation angle
      }

      update = (state, input, elapsed) => {
        state.angle = state.angle + elapsed / 10
      }

      draw = (state) => {
        clear()
        const { angle } = state
        range(8).forEach(i => {
          const halfSide = 8 * i / 2
          const topLeft = [64 - halfSide, 64 - halfSide]
          const topRight = [64 + halfSide, 64 - halfSide]
          const bottomRight = [64 + halfSide, 64 + halfSide]
          const bottomLeft = [64 - halfSide, 64 + halfSide]
          const color = i % 7

          // add 10 degrees to each successive square.
          // e.g. the first square gets 0 new degrees, the second one gets 10,
          // the third one gets 20, etc.
          const customAngle = angle + i * 10
          polyStroke([topLeft, topRight, bottomRight, bottomLeft], customAngle, color)
        })
      }
  - text:
    - We also need a way to keep track of total time passed.
    - Let's add that to `initialState`.
    screen: CODE
    game: |-
      initialState = {
        angle: 5 // the rotation angle
      }

      // given a number of milliseconds and square index,
      // returns the square's rotation
      const rotation = (milliseconds, i) => {
        return milliseconds * i
      }

      update = (state, input, elapsed) => {
        state.angle = state.angle + elapsed / 10
      }

      draw = (state) => {
        clear()
        const { angle } = state
        range(8).forEach(i => {
          const halfSide = 8 * i / 2
          const topLeft = [64 - halfSide, 64 - halfSide]
          const topRight = [64 + halfSide, 64 - halfSide]
          const bottomRight = [64 + halfSide, 64 + halfSide]
          const bottomLeft = [64 - halfSide, 64 + halfSide]
          const color = i % 7

          // add 10 degrees to each successive square.
          // e.g. the first square gets 0 new degrees, the second one gets 10,
          // the third one gets 20, etc.
          const customAngle = angle + i * 10
          polyStroke([topLeft, topRight, bottomRight, bottomLeft], customAngle, color)
        })
      }
  - text:
    - We also need a way to keep track of total time passed.
    - Let's add that to `initialState`.
    screen: CODE
    game: |-
      initialState = {
        totalElapsed: 0, // total time passed
        angle: 5 // the rotation angle
      }

      // given a number of milliseconds and square index,
      // returns the square's rotation
      const rotation = (milliseconds, i) => {
        return milliseconds * i
      }

      update = (state, input, elapsed) => {
        state.angle = state.angle + elapsed / 10
      }

      draw = (state) => {
        clear()
        const { angle } = state
        range(8).forEach(i => {
          const halfSide = 8 * i / 2
          const topLeft = [64 - halfSide, 64 - halfSide]
          const topRight = [64 + halfSide, 64 - halfSide]
          const bottomRight = [64 + halfSide, 64 + halfSide]
          const bottomLeft = [64 - halfSide, 64 + halfSide]
          const color = i % 7

          // add 10 degrees to each successive square.
          // e.g. the first square gets 0 new degrees, the second one gets 10,
          // the third one gets 20, etc.
          const customAngle = angle + i * 10
          polyStroke([topLeft, topRight, bottomRight, bottomLeft], customAngle, color)
        })
      }
  - text:
    - And what good is this `totalElapsed` if we don't change it?
    - "Let's do that in `update`:"
    screen: CODE
    game: |-
      initialState = {
        totalElapsed: 0, // total time passed
        angle: 5 // the rotation angle
      }

      // given a number of milliseconds and square index,
      // returns the square's rotation
      const rotation = (milliseconds, i) => {
        return milliseconds * i
      }

      update = (state, input, elapsed) => {
          state.angle = state.angle + elapsed / 10
      }

      draw = (state) => {
        clear()
        const { angle } = state
        range(8).forEach(i => {
          const halfSide = 8 * i / 2
          const topLeft = [64 - halfSide, 64 - halfSide]
          const topRight = [64 + halfSide, 64 - halfSide]
          const bottomRight = [64 + halfSide, 64 + halfSide]
          const bottomLeft = [64 - halfSide, 64 + halfSide]
          const color = i % 7

          // add 10 degrees to each successive square.
          // e.g. the first square gets 0 new degrees, the second one gets 10,
          // the third one gets 20, etc.
          const customAngle = angle + i * 10
          polyStroke([topLeft, topRight, bottomRight, bottomLeft], customAngle, color)
        })
      }
  - text:
    - new
    screen: CODE
    game: |-
      initialState = {
        totalElapsed: 0, // total time passed
        angle: 5 // the rotation angle
      }

      // given a number of milliseconds and square index,
      // returns the square's rotation
      const rotation = (milliseconds, i) => {
        return milliseconds * i
      }

      update = (state, input, elapsed) => {
          state.totalElapsed += elapsed
          state.angle = state.angle + elapsed / 10
      }

      draw = (state) => {
        clear()
        const { angle } = state
        range(8).forEach(i => {
          const halfSide = 8 * i / 2
          const topLeft = [64 - halfSide, 64 - halfSide]
          const topRight = [64 + halfSide, 64 - halfSide]
          const bottomRight = [64 + halfSide, 64 + halfSide]
          const bottomLeft = [64 - halfSide, 64 + halfSide]
          const color = i % 7

          // add 10 degrees to each successive square.
          // e.g. the first square gets 0 new degrees, the second one gets 10,
          // the third one gets 20, etc.
          const customAngle = angle + i * 10
          polyStroke([topLeft, topRight, bottomRight, bottomLeft], customAngle, color)
        })
      }
